---
date: 27-03-2025
tags:
  - problem
---
# Задача:
очень похожа на [[Рюкзак наибольшая стоимость]], но посложнее. Пока непонятно
Почему то повторяются индексы.
Надо смотреть сначала лекцию было, там ответ  про это https://www.youtube.com/watch?v=CgHXYmhTbSw&t=4041s

Почему [[Рюкзак наибольшая стоимость]] некорректно восстанавливает ответ, но корректно считает наибольшую стоимость? Потому что он считает наибольшую стоимость для каждого веса, отчего путь к весу с наибольшей стоимостью в целом уже перезаписан из-за других путей к меньшим стоимостям, но наибольшим локально для того веса, к которому они его считают.

# Draft

# Code

```python
n, m = map(int, input().split())  
weights = [0] + list(map(int, input().split()))  
costs = [0] + list(map(int, input().split()))  
pack = [[-1 for _ in range(m + 1)]]  
pack[0][0] = 0  
for i in range(1, n + 1):  
    #копируем предыдущую строку  
    row = pack[i - 1].copy()  
    pack.append(row)  
    # инициализируем вес и стоимость  
    w = weights[i]  
    c = costs[i]  
    for j in range(m - w, -1, -1):  
        if row[j] != -1 and row[j + w] < row[j] + c:  
            row[j + w] = row[j] + c  
  
row_index = n  
col_index = pack[row_index].index(max(pack[row_index]))  
path = []  
while row_index > 0 and col_index > 0:  
    row = pack[row_index]  
    cost = row[col_index]  
    if cost != -1:  
        weight = weights[row_index]  
        if col_index - weight >= 0 and pack[row_index][col_index] == pack[row_index - 1][col_index - weights[row_index]] + costs[row_index]:  
            col_index -= weight  
            path.append(row_index)  
    row_index -= 1  
  
for i in range(len(path) - 1, -1, -1):  
    print(path[i])
```

# Review
Чтобы тратить меньше времени на решение какой-то задачи, надо основательно подготовиться. 

На самом деле задача оказалась тяжелой. Рад, что я ее решил. Ключевая ошибка - неправильное восстановление пути, я без не учел вот это условие pack[row_index][col_index] == pack[row_index - 1][col_index - weights[row_index]] + costs[row_index]
- Если мы просто будем смотреть на то, что стоимость на текущем шаге равна какой-то максимальной стоимости, не проверяя, что она была получена с добавлением текущего предмета, то можем восстановить путь через не тот выбор предметов.

### Заключение

Проверка, что текущая ячейка равна стоимости, которая получается от предыдущей строки с добавлением текущего предмета, **гарантирует, что мы восстановим правильный путь**, который ведет к оптимальному решению. Это предотвращает случайный выбор неверных предметов, если в таблице ДП есть одинаковые значения для разных путей.

