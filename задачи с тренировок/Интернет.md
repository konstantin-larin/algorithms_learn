---
type: project
date: 27-03-2025
tags:
  - problem
---

# Задача:

Вход:
M секунд - нужно заполнить за минимальное количество денег
31 элемент a0...a30, где a_j - это количество секунд за 2^j рублей

Тут явно прослеживается

~~Короче заполняем массив длиной M [0, -1 ...., -1]~~
~~у нас элементы с a0 до a30 выставлены в порядке возрастания, что нас устраивает~~
~~допустим возьмем массив с a~~



**код не подошел**, так как M может быть 10**9, что очень много для памяти, если заполнить массив

```python
def solution(m, a):
    min_costs = [0] + [float('inf')] * m  # индексом является количество секунд, которое можно купить
    # последний индекс m + 1 - обозначает что можно купить m или больше секунд
    for i in range(len(a)):
        sec = a[i]
        for j in range(0, len(min_costs)):
            # берем вычисленное значение из min_costs[j]
            # смотрим на min_costs[j + sec], при этом если j + sec > m, то смотрим на min_costs[m]
            # если это число больше, чем 2 ** i + min_costs[j], то меняем его на это
            calc_cost = min_costs[j]
            view_sec = j + sec if j + sec < m else m
            if min_costs[view_sec] > 2 ** i + calc_cost:
                min_costs[view_sec] = 2 ** i + calc_cost
    return min_costs[-1]

m = int(input())
a = list(map(int, input().split()))

print(solution(m, a))
```



# Draft
![[Интернет 2025-04-11 08.43.07.excalidraw]]

# Code


```python
# динамическое программирование не подходит для этой задачи из-за большого M  
# идея: оставить пакеты только с уникальным количеством секунд, причем если есть несколько пакетов с одинаковым  
# количеством секунд, то оставить самый дешевый из них  
# затем отсортировать пакеты по тарифу руб/сек в порядке возрастания  
# а потом стараться заполнить необходимое количество секунд наивыгоднейшими пакетами  
  
def solution(m, a):  
    # сначала отфильтруем повторяющиеся в секундах пакеты  
    filtered_packs = [[2 ** 0, a[0]]] #[[cost, sec]]  
    for i in range(1, len(a)):  
        sec = a[i]  
        cost = 2 ** i  
        pack_is_in = False  
        for pack in filtered_packs:  
            if pack[1] == sec:  
                pack_is_in = True  
                if pack[0] > cost:  
                    pack[0] = cost  
                break  
        if not pack_is_in:  
            filtered_packs.append([cost, sec])  
  
    #сортируем по тарифу руб/сек  
    filtered_packs.sort(key=lambda x: x[0] / x[1])  
    min_sum = 0  
    # теперь наша задача пройтись по отфильтрованным пакетам и выбрать самое дешевое для m  
    i = 0  
    overpayments = [] #переплаты, которые потом мы будем сравнивать  
    # print(filtered_packs)    while m > 0 and i < len(filtered_packs):  
        #берем наилучший тариф  
        cost, sec = filtered_packs[i]  
        # print('следующий выгодный пакет', cost, '/', sec)  
        count = m // sec #сколько наивыгоднейших пакетов можно купить, не переплатив  
        m -= count * sec  
        min_sum += count * cost  
        # также понятно, что может быть такое, что именно переплатив на один выгодный пакет больше,  
        # мы сделаем сумму минимальной, поэтому запомним где-то этот результат, чтобы сравнить потом        # также очевидно, что оптимальная переплата - это покупка лишь одного пакета, не больше - поэтому        # плюс ко всему добавление такого значения в overpayments может говорить о том, что count == 0 и переплата неизбежна        overpayments.append(min_sum + cost)  
        i += 1  
    #после завершения цикла добавляем в переплаты посчитанную min_sum  
    overpayments.append(min_sum)  
    # print(overpayments)  
    return min(overpayments)  
  
    # теперь надо отсортировать массив в по секундам или по стоимости пока не решил  
    # суть такая, что m будет состоять из комбинаций вот этих вот отфильтрованных (самых дешевых) пакетов инета  
m = int(input())  
a = list(map(int, input().split()))  
  
print(solution(m, a))  
# 45  
# 1 1 3 12 24 22 56 101 300 559 2 620 315 219 491 863 579 144 802 61 615 279 137 277 981 666 647 305 686 843 224  
# 12 - 2 ** 3 * 45 // 12 = 8 * 4 = 32
```

# Review


Ну а так че по коду - сначала пытался сделать на дп, но потом понял, что это плохо так-то массив делать длиной 10^9 это очень плохо. Поэтому я стал очень думать как жееее как же это сделать. Вспомнил задачу Три единицы подряд - там конечно была работа со строками, но я понял, что принцип тут тот же. Мы должны искать наивыгоднейшие пакеты интернета по соотношению рубль/секунда и забивать ими свой прайс-лист. При этом нужно учитывать, что переплата может стать оптимальным решением или она может быть вовсе неизбежной и соответственно записывать такие варианты переплат в overpayments, продолжая жадно забивать выгодными пакетами свой чек в min_sum.
Эта задача учит правильному мышлению, лично я стопорнулся на том, что не учел, что M может быть равна 10^9 и сделал такой массив, за что позже поплатился. Плюс я теперь понял как можно решать такие задачи, по сути я понял, что такое жадный алгоритм.
